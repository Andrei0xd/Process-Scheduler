	
======================CLASELE DE BAZA======================
	Pentru implementarea temei, am decis ca, in primul rand, clasa Process sa fie una abstracta,
care desi contine argumente precum type ( tipul procesului ), times(numarul de rulari al procesului)
si weight( cota procesului ) care  apartin tuturor proceselor, va avea o metoda abstracta Run
care depinde de fiecare proces in parte. Astfel, putem crea un array the procese, in care fiecare
este un obiect diferit care extine clasa Process(), cu propria lui metoda de run.

	Scheduler va fi o interfata, deoarece singura ei metoda va fi Start, metoda care incepe schedulerul.
Aceasta va depinde de tipul de scheduler pe care il vom citi din fisierele de input, deci pentru inceput in main
putem face un obiect de tip Scheduler pe care apoi il asociem unui anumit tip de scheduler care implementeaza
interfata Scheduler.

======================Schedulers======================
	RandomScheduler - Pentru acest tip de scheduler, avem un numar generat aleator (Random.nextInt) pentru tipul procesului.
Iteram prin vectorul de numere ce trebuiesc procesate si apelam un proces random ( vectorDeProcese[randomInt] ).

	RoundRobinScheduler - Pentru acest tip de scheduler, iteram prin vectorul de procese si cautam procesul rulat de cele mai
putine ori ( data.getmin() ). Rulam acest proces pe numarul curent ce trebuie procesat.

	WeightedScheduler - Pentru acest tip de scheduler, facem mai intai cmmdc pentru cotele toate proceselor ( data.cmmdc() ) , dupa care
impartim fiecare cota in parte la cmmmdc ( data.updateWeights() ). Acum iteram prin vectorul de numere ce trebuie procesate
si rulam la rand procesele, pana cand process.times (de cate ori am rulat un proce) este egal cu cota lui, dupa care trecem la urmatorul.
Cand am terminat si cu ultimul proces din vectorul de procese, le resetam timpii. ( data.resetTimes() ).

======================BONUS - CACHE======================

	Pentru bonus, am decis sa fac o clasa StructLFU care va fi folosita drept structura atat pentru LFUCache cat si pentru LRUCache
Vom avea o interfata Cache, cu doua metode , ComputeCache ( care verifica daca un proces+rezultat se afla in cache) si UpdateCache, 
care adauga un proces+rezultat in cache

	LFUCache - Least frequently used - 
		UpdateCache - Metoda care adauga o structura de tipul StructLFU( care contine proces , numar de procesat si rezultat) in memoria
		cache. In cazul in care memoria nu este plina, il va adauga la final si va incrementa dimensiunea curenta a memoriei cache.
		In cazul in care memoria este plina, apeleaza metoda findlfu(), care va cauta procesul apelat de cele mai putine ori din
		memoria cache (least frequently used) si il va inlocui cu noul StructLFU
		
		ComputeCache - Metoda care itereaza prin vectorul de StructLFU si cauta procesul curent si numarul curent de procesat. Daca le gaseste, 
		incrementeaza usedTimes ( pentru ca tocmai am folosit acest proces ) si returneaza rezultatul. Daca nu il gaseste, returneaza "NotInCache",
		pentru ca Schedulerul sa stie ca va trebui sa foloseasca metoda Run() a acelui proces.
		
	LRUCache - Least recently used - 
		UpdateCache - Metoda care adauga o structura de tipul StructLFU( care contine proces , numar de procesat si rezultat) in memoria
		cache. In cazul in care memoria nu este plina, il va adauga la final si va incrementa dimensiunea curenta a memoriei cache.
		In cazul in care memoria este plina, vectorul este shiftat la stanga ( obiectul StructLFU de pe poztia 0 disparand, deoarece a fost 
		folosit "least recently") iar la sfarsitul vectorului se adauga noul nostru obiect StructLFU , pentru ca tocmai a fost folosit in 
		acest moment ( deci este most recently used)
		
		ComputeCache - Metoda care itereaza prin vectorul de StructLFU si cauta procesul curent si numarul curent de procesat. Daca le gaseste, 
		inseamna ca acest proces tocmai a fost folosit, deci devine most recently used. Astfel, de la pozitia curenta shiftam vectorul la stanga
		iar in varful lui punem procesul curent.(Astfel, intotdeauna vectorul este ordonat {least recently -> most recently} ). Daca nu il gaseste
		,returneaza NotInCache , pentru ca Schedulerul sa stie ca trebuie sa apeleze metoda Run a procesului. De asemenea, scheduler va apela
		metoda UpdateCache, care va adauga acest proces in Cache si astfel vectorul va ramane in continuare ordonat corect.
		
		
		